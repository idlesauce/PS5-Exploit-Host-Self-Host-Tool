using PS5_Exploit_Host_Self_Host_Tool;
using System.Security.Cryptography.X509Certificates;
using System.Net;
using System.Security.Cryptography;
using Microsoft.AspNetCore.StaticFiles;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Hosting;
using System.Reflection;
using System.Text;

AppDomain.CurrentDomain.UnhandledException += (sender, a) =>
{
	Exception ex = (Exception)a.ExceptionObject;
	Console.WriteLine($"Unhandled exception: {ex.GetType().Name}: {ex.Message}");
	if (ex.InnerException is not null)
	{
		Console.WriteLine($"Inner exception: {ex.InnerException.GetType().Name}: {ex.InnerException.Message}");
	}
	Environment.Exit(1);
};

if (!File.Exists(Config.ConfigFilePath))
{
	var defaultConfig = new Config();

	if (args.Any(x => x == "--default-config-wifi-ap"))
	{
		defaultConfig.EnableWifiAP = true;
		defaultConfig.ServersBindIP = defaultConfig.WifiAPAssignIp;
		defaultConfig.TargetIP = defaultConfig.WifiAPAssignIp;
	}

	await IniParser.SaveToFile(defaultConfig, Config.ConfigFilePath);

	if (!args.Any(x => x == "--default-config-continue"))
	{
		Console.WriteLine($"Config file not found, created default config file at '{Config.ConfigFilePath}', please review settings and verify the detected IP address is the one that is on the same network as your PS5.");
		Environment.Exit(1);
	}

	Console.WriteLine($"Config file not found, created default config file at '{Config.ConfigFilePath}', continuing with default settings");
}

Console.WriteLine($"Using config file '{Config.ConfigFilePath}'");
var config = await IniParser.Parse<Config>(Config.ConfigFilePath);

// overwrite config with parsed version in case there were missing properties and we reverted to default
await IniParser.SaveToFile(config, Config.ConfigFilePath);

Directory.CreateDirectory(Config.WWWRootPath);
Directory.CreateDirectory(Config.AppDataPath);
Directory.CreateDirectory(Config.NonUserEditableFilesPath);

Console.WriteLine($"Using wwwroot folder '{Config.WWWRootPath}'");

var builder = WebApplication.CreateSlimBuilder(args);

builder.Logging.ClearProviders();
builder.Logging.AddSimpleConsole(options =>
{
	options.IncludeScopes = false;
	options.SingleLine = true;
});

if (config.EnableVerboseLogging)
{
	builder.Configuration["Logging:LogLevel:Default"] = "Trace";
}

builder.Services.AddSingleton(config);

builder.WebHost.ConfigureKestrel(options =>
{
	if (config.HttpPort is not null)
	{
		options.Listen(config.ServersBindIP, config.HttpPort.Value);
	}

	if (config.HttpsPort is not null)
	{
		using var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream($"PS5_Exploit_Host_Self_Host_Tool.localhost.pfx");

		if (stream is null)
		{
			throw new Exception("Failed to load localhost.pfx from resources");
		}

		var bytes = new byte[stream.Length];
		stream.ReadExactly(bytes, 0, bytes.Length);

		var cert = new X509Certificate2(bytes);

		options.Listen(config.ServersBindIP, config.HttpsPort.Value, listenOptions =>
		{
			listenOptions.UseHttps(cert);
		});
	}
});

if (config.EnableHostFilesAutoUpdater && Config.WWWRootPath == System.AppContext.BaseDirectory)
{
	// wwwroot will be the same folder as the exe if theres an index.html there
	// and the updater deletes files that are not in the new update
	// so disable the auto updater if the wwwroot is the same as the exe folder
	Console.WriteLine("Disabling host files auto updater because the hosted folder isnt wwwroot");
	config.EnableHostFilesAutoUpdater = false;
}

if (config.EnableHostFilesAutoUpdater)
{
	builder.Services.AddHostedService<AutoUpdateService>();
}

var host = builder.Build();
ILogger<Program> logger = host.Services.GetRequiredService<ILogger<Program>>();

if (config.EnableHostFilesAutoUpdater)
{
	var autoUpdater = host.Services.GetServices<IHostedService>().OfType<AutoUpdateService>().Single();
	await autoUpdater.StartupFetchIfNeeded();
}

// the ap should be up before servers since this will likely be the thing to create the interface they bind to
if (config.EnableWifiAP)
{
	var apLogger = host.Services.GetRequiredService<ILogger<AccessPoint.AccessPoint>>();

	var accessPoint = new AccessPoint.AccessPoint(config, apLogger);
	AppDomain.CurrentDomain.ProcessExit += async (sender, e) =>
	{
		Console.WriteLine("Stopping AP...");
		await accessPoint.Stop();
		Console.WriteLine("AP stopped");
	};

	await accessPoint.Start();
}

if (config.EnableDnsServer)
{
	if (config.KillProcessessUsingDnsPort)
	{
		Killer.KillAllProcessesUsingUdpPort(53, config.KillSvchost, host.Services.GetRequiredService<ILogger<Killer>>());
	}
	var dnsServer = new DnsServerWrapper(config, host.Services.GetRequiredService<ILogger<DnsServerWrapper>>());
	dnsServer.ServeForever();
}

if (config.HttpPort is null && config.HttpsPort is null)
{
	if (!config.EnableDnsServer)
	{
		Console.WriteLine("All servers are disabled, exiting...");
		Environment.Exit(1);
	}

	Utils.NotifySystemdReadyIfNeeded(logger);
	// wait forever is only the dns server is enabled
	while (true)
	{
		await Task.Delay(1000);
	}
}

#if WINDOWS10_0_17763_0_OR_GREATER
if (config.EnableWifiAP && !config.TargetIP.Equals(IPAddress.Parse("192.168.137.1")))
{
	logger.LogWarning($"[!] Wifi AP is enabled but the target IP ({nameof(Config.TargetIP)}) is not set the WIFI AP IP (192.168.137.1)");
}
if (config.EnableWifiAP && !config.ServersBindIP.Equals(IPAddress.Parse("192.168.137.1")) && !config.ServersBindIP.Equals(IPAddress.Any))
{
	logger.LogWarning($"[!] Wifi AP is enabled but the server bind IP ({nameof(Config.ServersBindIP)}) is not set to the WIFI AP IP (192.168.137.1) or 0.0.0.0");
}
#else
if (config.EnableWifiAP && !config.TargetIP.Equals(config.WifiAPAssignIp))
{
	logger.LogWarning($"[!] Wifi AP is enabled but the target IP ({nameof(Config.TargetIP)}) is not set the WIFI AP IP ({nameof(Config.WifiAPAssignIp)})");
}
if (config.EnableWifiAP && !config.ServersBindIP.Equals(config.WifiAPAssignIp) && !config.ServersBindIP.Equals(IPAddress.Any))
{
	logger.LogWarning($"[!] Wifi AP is enabled but the server bind IP ({nameof(Config.ServersBindIP)}) is not set to the WIFI AP IP ({nameof(Config.WifiAPAssignIp)}) or 0.0.0.0");
}
#endif

var contentTypeProvider = new FileExtensionContentTypeProvider();

host.MapGet("{**path}", async (string? path, HttpContext context, ILogger<Program> logger) =>
{
	logger.LogTrace("Request path: {path}", path);

	if (!string.IsNullOrWhiteSpace(path))
	{
		// if user guide path, remove the document/x/ps5 part
		var match = Utils.UserGuidePathRegex().Match(path);

		if (match.Success)
		{
			path = path.Substring(match.Length);
		}
	}

	if (string.IsNullOrWhiteSpace(path) || path == "/")
	{
		path = "index.html";
	}


	var filePath = Path.GetFullPath(Path.Combine(Config.WWWRootPath, path.TrimStart('/')));

	if (path.EndsWith(".manifest") || path.EndsWith(".appcache"))
	{
		if (config.BlockAppCacheRequestsOnHttps && context.Request.IsHttps)
		{
			context.Response.StatusCode = 404;
			return;
		}

		if (config.DynamicallyGenerateAppcache)
		{
			context.Response.ContentType = "text/cache-manifest";
			var realTargetFolder = Path.GetDirectoryName(filePath)!;
			await context.Response.WriteAsync(Utils.GenerateAppcacheManifestForFolder(realTargetFolder));
			logger.LogTrace("Sent generated appcache manifest for folder: {realTargetFolder}", realTargetFolder);
			return;
		}
	}

	// avoid path traversal (filepath is resolved by Path.GetFullPath)
	// it seems the framework already strips "/..", at least the way i get the path, but i havent found official documentation on this // TODO: look into this properly
	if (!filePath.StartsWith(Config.WWWRootPath))
	{
		context.Response.StatusCode = 404;
		return;
	}

	if (!File.Exists(filePath))
	{
		context.Response.StatusCode = 404;
		return;
	}

	// Set content type
	if (!contentTypeProvider.TryGetContentType(filePath, out var contentType))
	{
		contentType = "application/octet-stream"; // fallback
	}
	context.Response.ContentType = contentType;

	await context.Response.SendFileAsync(filePath);
});

// download host files if auto updater is enabled and there isnt an index.html file already
if (!File.Exists(Path.Combine(Config.WWWRootPath, "index.html")) && config.EnableHostFilesAutoUpdater)
{
	var autoUpdater = host.Services.GetServices<IHostedService>().OfType<AutoUpdateService>().Single();
	await autoUpdater.DownloadLatestAndExtract();
}

host.Services.GetService<IHostApplicationLifetime>()!.ApplicationStarted.Register(() => Utils.NotifySystemdReadyIfNeeded(host.Services.GetRequiredService<ILogger<Program>>()));

await host.RunAsync();

