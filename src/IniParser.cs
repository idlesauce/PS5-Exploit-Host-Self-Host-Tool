using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Reflection;
using System.Text;

namespace PS5_Exploit_Host_Self_Host_Tool;

[AttributeUsage(AttributeTargets.Property)]
public class IniPropertyAttribute : Attribute
{
	public string? Comment { get; set; }
}

[AttributeUsage(AttributeTargets.Class)]
public class IniHeaderAttribute : Attribute
{
	public string? Header { get; set; }
	public string? Comment { get; set; }
}

internal static class IniParser
{
	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(Config))]
	[RequiresUnreferencedCode("IniParser.SaveToFile uses reflection, DynamicDependency attribute is required for classes that use this method in nativeAOT mode")]
	public static async Task SaveToFile<T>(T obj, string path)
	{
		var classAttribute = typeof(T).GetCustomAttribute<IniHeaderAttribute>();
		var header = classAttribute?.Header ?? typeof(T).Name;
		var comment = classAttribute?.Comment;

		var properties = typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance);

		var sb = new StringBuilder();
		sb.AppendLine($"[{header}]");
		if (comment != null)
		{
			foreach (var line in comment.Split('\n'))
			{
				sb.AppendLine($"# {line}");
			}
		}

		sb.AppendLine();

		foreach (var property in properties)
		{
			var attribute = property.GetCustomAttribute<IniPropertyAttribute>();
			if (attribute?.Comment != null)
			{
				foreach (var line in attribute.Comment.Split('\n'))
				{
					sb.AppendLine($"# {line}");
				}
			}
			var value = property.GetValue(obj)?.ToString();
			sb.AppendLine($"{property.Name}={value}");
			sb.AppendLine();
		}

		Directory.CreateDirectory(Path.GetDirectoryName(path)!);

		await File.WriteAllTextAsync(path, sb.ToString());
	}

	[DynamicDependency(DynamicallyAccessedMemberTypes.PublicProperties, typeof(Config))]
	[RequiresUnreferencedCode("IniParser.Parse uses reflection, DynamicDependency attribute is required for classes that use this method in nativeAOT mode")]
	public static async Task<T> Parse<T>(string path) where T : new()
	{
		if (!File.Exists(path))
		{
			throw new FileNotFoundException("Ini file not found", path);
		}

		var result = new T();
		var properties = typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)
								  .ToDictionary(p => p.Name, p => p);


		foreach (var line in await File.ReadAllLinesAsync(path))
		{
			if (string.IsNullOrWhiteSpace(line) || line.StartsWith('#') || line.StartsWith('[') || !line.Contains('='))
			{
				continue;
			}

			var parts = line.Split('=');
			if (parts.Length != 2)
			{
				throw new FormatException("Invalid ini file format");
			}

			var key = parts[0].Trim();
			var value = parts[1].Trim();

			if (properties.TryGetValue(key, out var property))
			{
				var propertyType = property.PropertyType;
				object? convertedValue;
                if (string.IsNullOrEmpty(value))
                {
                    convertedValue = null;
                }
				else if (propertyType.IsEnum)
				{
					convertedValue = Enum.Parse(propertyType, value);
				}
				else if (propertyType == typeof(IPAddress))
				{
					convertedValue = IPAddress.Parse(value);
				}
				else if (propertyType == typeof(bool))
				{
					convertedValue = bool.Parse(value);
				}
                else if (propertyType == typeof(int?))
                {
                    convertedValue = int.Parse(value);
                }
				else if (propertyType == typeof(List<string>))
				{
					convertedValue = value.Split(',').Select(x => x.Trim()).ToList();
				}
				else
				{
					convertedValue = Convert.ChangeType(value, propertyType);
				}
				property.SetValue(result, convertedValue);
			}
		}

		return result;
	}
}
