#if WINDOWS10_0_17763_0_OR_GREATER
using Windows.Devices.WiFiDirect;
#endif

using PS5_Exploit_Host_Self_Host_Tool;
using System.Diagnostics;

namespace AccessPoint;

public class AccessPoint
{
    private readonly Config config;
    private readonly ILogger<AccessPoint> logger;
#if WINDOWS10_0_17763_0_OR_GREATER
    WiFiDirectAdvertisementPublisher? publisher;
#endif

    public AccessPoint(Config config, ILogger<AccessPoint> logger)
    {
        this.config = config;
        this.logger = logger;

#if WINDOWS
        // the WINDOWS10_0_17763_0 RID just includes extra stuff but it still runs on windows 7 so do a runtime check
        if (Environment.OSVersion.Version < new Version(10, 0, 17763, 0))
        {
            throw new PlatformNotSupportedException("WiFi APs are only supported on Windows 10 1809+ (windows10.0.17763.0+) and Linux. Disable this feature in the config file and restart.");
        }
#endif
#if WINDOWS10_0_17763_0_OR_GREATER
        // Check if WiFi Direct is supported
        if (WiFiDirectDevice.GetDeviceSelector() == null)
        {
            throw new Exception("WiFi Direct is not supported on this device.");
        }
#else
        if (Environment.OSVersion.Platform == PlatformID.Unix)
        {
            // Check if running as root
            if (!IsRunningAsRoot().GetAwaiter().GetResult())
            {
                throw new Exception("This application must be run as root to set up a WiFi hotspot.");
            }
        }
        else
        {
            throw new Exception("Wifi APs are only supported on Windows and Linux. Disable this feature in the config file and restart.");
        }
#endif
    }

    public async Task Start()
    {
#if WINDOWS10_0_17763_0_OR_GREATER
        publisher = new WiFiDirectAdvertisementPublisher();

        publisher.Advertisement.IsAutonomousGroupOwnerEnabled = true;
        publisher.Advertisement.LegacySettings.IsEnabled = true;
        publisher.Advertisement.LegacySettings.Ssid = config.WifiAPSSID;
        publisher.Advertisement.LegacySettings.Passphrase.Password = config.WifiAPPassword;
        publisher.Advertisement.ListenStateDiscoverability = WiFiDirectAdvertisementListenStateDiscoverability.Intensive;

        publisher.Start();
        // I think the start function is synchronous, but since the StatusChanged event subscription is broken in aot mode, poll the status for a lil bit
        for (int i = 0; i < 50; i++) // 5 seconds
        {
            if (publisher.Status == WiFiDirectAdvertisementPublisherStatus.Started)
            {
                logger.LogInformation("WiFi AP started successfully.");
                return;
            }
            await Task.Delay(100);
        }

        try
        {
            publisher.Stop();
        }
        catch (System.Exception)
        { }

        throw new Exception("Failed to start WiFi AP.");
#else
        if (Environment.OSVersion.Platform == PlatformID.Unix)
        {
            await StartLinuxHotspot();
            return;
        }
        else
        {
            // ctor throws if not supported so this should be unreachable
            throw new UnreachableException("Wifi APs are only supported on Windows 10+ and Linux. Disable this feature in the config file and restart.");
        }
#endif
    }

    public async Task Stop()
    {
        logger.LogInformation("Stopping WiFi AP...");
#if WINDOWS10_0_17763_0_OR_GREATER
        publisher?.Stop();
#else
        if (Environment.OSVersion.Platform == PlatformID.Unix)
        {
            await StopLinuxHotspot();
        }
#endif
        logger.LogInformation("WiFi AP stopped.");
    }

    // dotnet doesnt have a built-in preprocessor symbol for linux... i could define it myself but meh
    // https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives
#if !WINDOWS && !MACOS && !ANDROID && !IOS && !BROWSER && !TVOS
    private async Task StartLinuxHotspot()
    {
        // if a command doesnt exit with 0 itll throw an exception, which exits the program, which triggers Stop() which will stop hostapd and dnsmasq if they're running
        // this implicit shit makes this bad code but fuck it

        await StopLinuxHotspot();

        string hostapdConfig = $"""
        interface={config.WifiAPVirtualInterface}
        driver=nl80211
        ssid={config.WifiAPSSID}
        hw_mode=g
        channel=7
        wmm_enabled=0
        macaddr_acl=0
        auth_algs=3
        ignore_broadcast_ssid=0
        wpa=2
        wpa_passphrase={config.WifiAPPassword}
        wpa_key_mgmt=WPA-PSK
        rsn_pairwise=CCMP
        """;

        File.WriteAllText(Path.Combine(Config.NonUserEditableFilesPath, "hostapd.conf"), hostapdConfig.Replace("\r\n", "\n")); // hostapd doesn't like windows line endings
        logger.LogInformation("Created hostapd configuration.");

        var ipBytes = config.WifiAPAssignIp.GetAddressBytes();
        var firstThreeParts = $"{ipBytes[0]}.{ipBytes[1]}.{ipBytes[2]}";

        // dnsmasq config, port=0 to disable the dns server
        // dhcp-option=6,x to set the dhcp assigned dns server
        string dnsmasqConfig = $"""
        interface={config.WifiAPVirtualInterface}
        dhcp-range={firstThreeParts}.2,{firstThreeParts}.200,255.255.255.0,24h
        port=0
        dhcp-option=6,{config.WifiAPAssignIp}
        """;

        File.WriteAllText(Path.Combine(Config.NonUserEditableFilesPath, "dnsmasq.conf"), dnsmasqConfig);
        logger.LogInformation("Created dnsmasq configuration.");

        // Reset the main interface
        // logger.LogInformation("Resetting main interface {mainInterface}...", config.WifiAPWifiInterface);
        // await RunCommand($"ip link set {config.WifiAPWifiInterface} down");
        // await RunCommand($"ip link set {config.WifiAPWifiInterface} up");
        // logger.LogInformation("Reset main interface {mainInterface}.", config.WifiAPWifiInterface);

        // Create a virtual interface
        await RunCommand($"iw dev {config.WifiAPWifiInterface} interface add {config.WifiAPVirtualInterface} type __ap");
        logger.LogInformation("Created virtual interface {virtualInterface}.", config.WifiAPVirtualInterface);

        // Wait until the interface is up, otherwise the ip assignment wont work
        bool interfaceUp = false;
        for (int i = 0; i < 10; i++)
        {
            var output = await RunCommand($"ifconfig {config.WifiAPVirtualInterface}");
            if (output.Contains("<UP", StringComparison.InvariantCultureIgnoreCase))
            {
                logger.LogInformation("Virtual interface {virtualInterface} is up.", config.WifiAPVirtualInterface);
                interfaceUp = true;
                break;
            }
            logger.LogWarning("Virtual interface {virtualInterface} is not up, retrying...", config.WifiAPVirtualInterface);
            await Task.Delay(1000);
        }

        if (!interfaceUp)
        {
            throw new Exception("Virtual interface is not up in 10 seconds.");
        }

        // Assign a static IP to the virtual interface
        await RunCommand($"ifconfig {config.WifiAPVirtualInterface} {config.WifiAPAssignIp} netmask 255.255.255.0");
        logger.LogInformation("Assigned static IP {ip} to virtual interface {virtualInterface}.", config.WifiAPAssignIp, config.WifiAPVirtualInterface);

        // Enable IP forwarding
        await RunCommand("sysctl -w net.ipv4.ip_forward=1");
        logger.LogInformation("Enabled IP forwarding.");

        // Start hostapd
        logger.LogInformation("Starting hostapd...");
        bool hostapdUp = false;
        for (int i = 0; i < 5; i++)
        {
            // retry, i had ran into this issue where hostapd fails saying "Could not connect to kernel driver"
            // a delay before seemed to fix it so i guess something wasnt ready yet, even though ifconfig says UP
            // but i cant reproduce the issue anymore so this is untested
            try
            {
                await RunCommand($"hostapd -B {Path.Combine(Config.NonUserEditableFilesPath, "hostapd.conf")} -P {Path.Combine(Config.NonUserEditableFilesPath, "hostapd.pid")}");
                hostapdUp = true;
                break;
            }
            catch (System.Exception)
            {
                logger.LogWarning("Failed to start hostapd, retrying...");
                await Task.Delay(1000);
            }
        }

        if (!hostapdUp)
        {
            throw new Exception("Failed to start hostapd.");
        }

        logger.LogInformation("Started hostapd.");

        // Start dnsmasq
        logger.LogInformation("Starting dnsmasq...");
        await RunCommand($"dnsmasq -C {Path.Combine(Config.NonUserEditableFilesPath, "dnsmasq.conf")} -x {Path.Combine(Config.NonUserEditableFilesPath, "dnsmasq.pid")}");
        logger.LogInformation("Started dnsmasq.");

        if (config.EnableWifiAPInternetAccess)
        {
            await Task.WhenAll(
                RunCommand($"iptables -t nat -A POSTROUTING -o {config.WifiAPWifiInterface} -j MASQUERADE"),
                RunCommand($"iptables -A FORWARD -i {config.WifiAPWifiInterface} -o {config.WifiAPVirtualInterface} -m state --state RELATED,ESTABLISHED -j ACCEPT"),
                RunCommand($"iptables -A FORWARD -i {config.WifiAPVirtualInterface} -o {config.WifiAPWifiInterface} -j ACCEPT")
            );
            logger.LogInformation("Set up iptables rules for internet access.");
        }

        if (config.EnableWifiAPDnsHijacking)
        {
            await Task.WhenAll(
                RunCommand($"iptables -t nat -A PREROUTING -i {config.WifiAPVirtualInterface} -p udp --dport 53 -j DNAT --to-destination {config.WifiAPAssignIp}"),
                RunCommand($"iptables -t nat -A PREROUTING -i {config.WifiAPVirtualInterface} -p tcp --dport 53 -j DNAT --to-destination {config.WifiAPAssignIp}")
            );
            logger.LogInformation("Set up iptables rules for DNS hijacking.");
        }

        logger.LogInformation("WiFi AP up.");
    }

    private async Task StopLinuxHotspot()
    {
        logger.LogInformation("Stopping hostapd...");
        await RunCommand($"kill $(cat {Path.Combine(Config.NonUserEditableFilesPath, "hostapd.pid")})", false);
        logger.LogInformation("Stopped hostapd.");

        logger.LogInformation("Stopping dnsmasq...");
        await RunCommand($"kill $(cat {Path.Combine(Config.NonUserEditableFilesPath, "dnsmasq.pid")})", false);
        logger.LogInformation("Stopped dnsmasq.");

        // delete old virtual interfaces
        // var interfaces = await GetIwDevInterfaces();

        // var physicalInterfaceNameForConfigWifiInterface = interfaces.First(x => x.interfaceName == config.WifiAPWifiInterface).physicalInterfaceName;
        // foreach (var (interfaceName, physicalInterfaceName, type) in interfaces.Where(x => x.physicalInterfaceName == physicalInterfaceNameForConfigWifiInterface))
        // {
        //     // if managed or AP and its not the main interface then delete it
        //     if ((type.Equals("managed", StringComparison.InvariantCultureIgnoreCase) ||
        //         type.Equals("AP", StringComparison.InvariantCultureIgnoreCase)
        //         ) && 
        //         interfaceName != config.WifiAPWifiInterface)
        //     {
        //         await RunCommand($"iw dev {interfaceName} del");
        //         logger.LogInformation("Deleted virtual interface {interfaceName}.", interfaceName);
        //     }
        // }

        await RunCommand($"iw dev {config.WifiAPVirtualInterface} del", false);
        logger.LogInformation("Deleted virtual interface {virtualInterface}.", config.WifiAPVirtualInterface);

        // Disable IP forwarding
        await RunCommand("sysctl -w net.ipv4.ip_forward=0");
        logger.LogInformation("Disabled IP forwarding.");

        // Delete all iptables rules that mention the virtual interface
        await RunCommand($"iptables-save | grep -v \"{config.WifiAPVirtualInterface}\" | iptables-restore");
        await RunCommand($"iptables -t nat -D POSTROUTING -o {config.WifiAPWifiInterface} -j MASQUERADE", false);
        logger.LogInformation("Removed iptables rules for virtual interface {virtualInterface}.", config.WifiAPVirtualInterface);
    }

    // public async Task<List<(string interfaceName, string physicalInterfaceName, string type)>> GetIwDevInterfaces()
    // {
    //     var output = await RunCommand("iw dev");
    //     var lines = output.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
    //     var interfaces = new List<(string interfaceName, string physicalInterfaceName, string type)>();
    //     string? lastPhy = null;

    //     foreach (var line in lines)
    //     {
    //         if (line.StartsWith("phy#"))
    //         {
    //             lastPhy = line.Trim();
    //         }
    //         else if (line.Contains("Interface", StringComparison.InvariantCultureIgnoreCase))
    //         {
    //             if (string.IsNullOrWhiteSpace(lastPhy))
    //             {
    //                 throw new Exception("Physical interface name not found.");
    //             }
    //             var interfaceName = line.Substring(line.IndexOf("interface", StringComparison.InvariantCultureIgnoreCase) + "interface".Length).Trim();
    //             interfaces.Add((interfaceName, lastPhy, null)!);
    //         }
    //         else if (line.Contains("type", StringComparison.InvariantCultureIgnoreCase))
    //         {
    //             var type = line.Substring(line.IndexOf("type", StringComparison.InvariantCultureIgnoreCase) + "type".Length).Trim();
    //             interfaces[^1] = (interfaces[^1].interfaceName, interfaces[^1].physicalInterfaceName, type);
    //         }
    //     }

    //     return interfaces;
    // }

    private async Task<string> RunCommand(string command, bool throwOnError = true)
    {
        logger.LogTrace("Running command '{command}'...", command);
        var processInfo = new ProcessStartInfo("bash", $"-c \"{command}\"")
        {
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var process = Process.Start(processInfo)!;
        using var reader = process.StandardOutput;
        var output = await reader.ReadToEndAsync();
        await process.WaitForExitAsync();
        if (process.ExitCode != 0 && throwOnError)
        {
            using var errorReader = process.StandardError;
            var error = errorReader.ReadToEnd();
            throw new Exception($"Command '{command}' failed with exit code {process.ExitCode}.\n{output}\n{error}");
        }

        logger.LogTrace("Command '{command}' exited with code {exitcode}.", command, process.ExitCode);

        return output;
    }

    private async Task<bool> IsRunningAsRoot()
    {
        return (await RunCommand("id -u")).Trim() == "0";
    }
#endif
}