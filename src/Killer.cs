namespace PS5_Exploit_Host_Self_Host_Tool;

using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Principal;

internal class Killer
{
	internal static void KillAllProcessesUsingUdpPort(int port, bool killSvcHost, ILogger<Killer> logger)
	{
#if WINDOWS
		logger.LogTrace("Getting pids using UDP port {port}", port);
		var processIds = GetProcessIdsUsingPort(port);
		logger.LogTrace("Found {count} processes using UDP port {port}", processIds.Length, port);

		IEnumerable<int> yearningForDeath = processIds;
		if (port == 53 && !killSvcHost)
		{
			// TODO: take in target ip too maybe.. the way it seems to work is that svchost binds to udp 53 on 0.0.0.0, so a specific interface ip binding works just not 0.0.0.0
			// ig svchost is also the dhcp server (if i kill it, my phone is only able to connect if i have a static ip set)
			// even if i dont kill it i can still bind to udp 53 it so it doesnt matter
			yearningForDeath = processIds.Where(pid => !Process.GetProcessById(pid).ProcessName.Contains("svchost"));
		}

		if (yearningForDeath.Count() == 0)
		{ return; }

		// we need elevated permissions to kill processes
		if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator))
		{
			throw new InvalidOperationException($"UDP port {port} is in use by one or more processes, but the current user does not have the required permissions to kill them. Please run this program as administrator.");
		}

		foreach (var pid in yearningForDeath)
		{
			Process process = Process.GetProcessById(pid);

			try
			{
				logger.LogTrace("Killing process {processName} (PID: {pid}) using UDP port {port}", process.ProcessName, pid, port);
				process.Kill();
				logger.LogInformation("Killed process {processName} (PID: {pid}) using UDP port {port}", process.ProcessName, pid, port);
			}
			catch (Exception ex)
			{
				logger.LogError(ex, "Failed to kill process with PID {pid}", pid);
			}
		}
#else
		if (Environment.OSVersion.Platform == PlatformID.Unix)
		{
			using var proc = new Process
			{
				StartInfo = new ProcessStartInfo
				{
					FileName = "fuser",
					Arguments = $"-k -n udp {port}",
					UseShellExecute = false,
					RedirectStandardOutput = true,
					RedirectStandardError = true,
					CreateNoWindow = true
				}
			};

			proc.Start();
			proc.WaitForExit();

			if (proc.ExitCode != 0)
			{
				logger.LogError("Failed to kill processes using UDP port {port}. fuser exited with code {exitCode}.", port, proc.ExitCode);
			}
			else
			{
				logger.LogInformation("Killed processes using UDP port {port}.", port);
			}
		}
		else
		{
			logger.LogWarning("KillAllProcessesUsingUdpPort is not supported on this platform.");
		}
#endif

	}

#if WINDOWS
	private static int[] GetProcessIdsUsingPort(int port)
	{
		int bufferSize = 0;

		// get the buffer size needed
		uint result = GetExtendedUdpTable(IntPtr.Zero, ref bufferSize, true, AF_INET, UDP_TABLE_OWNER_PID, 0);
		var udpTable = Marshal.AllocHGlobal(bufferSize);

		try
		{
			result = GetExtendedUdpTable(udpTable, ref bufferSize, true, AF_INET, UDP_TABLE_OWNER_PID, 0);
			if (result != 0)
			{
				return Array.Empty<int>();
			}

			MIB_UDPTABLE_OWNER_PID table = (MIB_UDPTABLE_OWNER_PID)Marshal.PtrToStructure(udpTable, typeof(MIB_UDPTABLE_OWNER_PID));
			MIB_UDPROW_OWNER_PID[] rows = new MIB_UDPROW_OWNER_PID[table.dwNumEntries];
			IntPtr rowPtr = (IntPtr)((long)udpTable + Marshal.SizeOf(table.dwNumEntries));

			var processIds = new List<int>();

			for (int i = 0; i < table.dwNumEntries; i++)
			{
				rows[i] = (MIB_UDPROW_OWNER_PID)Marshal.PtrToStructure(rowPtr, typeof(MIB_UDPROW_OWNER_PID));
				rowPtr = (IntPtr)((long)rowPtr + Marshal.SizeOf(typeof(MIB_UDPROW_OWNER_PID)));

				// Convert port from network byte order to host byte order
				int localPort = (int)rows[i].dwLocalPort;
				localPort = ((localPort & 0xFF) << 8) | ((localPort >> 8) & 0xFF);


				if (localPort == port)
				{
					// uint ip = rows[i].dwLocalAddr;
					// string boundIp = $"{ip & 0xFF}.{(ip >> 8) & 0xFF}.{(ip >> 16) & 0xFF}.{(ip >> 24) & 0xFF}";
					// Console.WriteLine(boundIp);
					processIds.Add((int)rows[i].dwOwningPid);
				}
			}

			return processIds.Distinct().ToArray();
		}
		finally
		{
			Marshal.FreeHGlobal(udpTable);
		}
	}


	const int AF_INET = 2;
	const int UDP_TABLE_OWNER_PID = 1;

	[DllImport("iphlpapi.dll")]
	static extern uint GetExtendedUdpTable(IntPtr pUdpTable, ref int pdwSize, bool bOrder, int ulAf, int TableClass, int Reserved);

	[StructLayout(LayoutKind.Sequential)]
	struct MIB_UDPTABLE_OWNER_PID
	{
		public uint dwNumEntries;
		public MIB_UDPROW_OWNER_PID table;
	}

	[StructLayout(LayoutKind.Sequential)]
	struct MIB_UDPROW_OWNER_PID
	{
		public uint dwLocalAddr;
		public uint dwLocalPort;
		public uint dwOwningPid;
	}

#endif
}
