using Microsoft.Net.Http.Headers;
using System.IO.Compression;
using System.Net.Http.Headers;

namespace PS5_Exploit_Host_Self_Host_Tool;
internal class AutoUpdateService : BackgroundService
{
	private const string cacheVersionUrl = "https://github.com/idlesauce/PS5-Exploit-Host/releases/download/latest/ps5-exploit-host_appcache.zip";
	private const string nocacheVersionUrl = "https://github.com/idlesauce/PS5-Exploit-Host/releases/download/latest/ps5-exploit-host_no-appcache.zip";
	private readonly Config config;
	private readonly ILogger<AutoUpdateService> logger;
	private readonly PeriodicTimer timer;

	private static readonly string lastEtagFilePath = Path.Combine(Config.NonUserEditableFilesPath, "auto-updater-last-etag");
	private static readonly string lastDownloadedVersionFilePath = Path.Combine(Config.NonUserEditableFilesPath, "auto-updater-last-downloaded-version");
	private readonly HttpClient httpClient;

	private (string url, string? pathToFolderInDownloadedZip) downloadUrl
	{
		get
		{
			if (config.HostFilesAutoUpdaterSource == "appcache")
			{
				return (cacheVersionUrl, null);
			}
			else if (config.HostFilesAutoUpdaterSource == "no-appcache")
			{
				return (nocacheVersionUrl, null);
			}

			if (!Uri.TryCreate(config.HostFilesAutoUpdaterSource, UriKind.Absolute, out var parsedUrl))
			{
				throw new ArgumentException("Invalid HostFilesAutoUpdaterSource, must be 'appcache', 'no-appcache' or a .zip download link or github repo url", nameof(Config.HostFilesAutoUpdaterSource));
			}

			if (parsedUrl.AbsolutePath.EndsWith(".zip"))
			{
				return (config.HostFilesAutoUpdaterSource, null);
			}

			if (parsedUrl.Host != "github.com")
			{
				throw new ArgumentException("Invalid HostFilesAutoUpdaterSource, must be 'appcache', 'no-appcache' or a .zip download link or github repo url", nameof(Config.HostFilesAutoUpdaterSource));
			}

			
			var tree = "main";
			if (parsedUrl.AbsolutePath.Contains("/tree/"))
			{
				tree = parsedUrl.AbsolutePath.Split("/tree/")[1].Split('/')[0];
			}

			var ownerSlashRepo = string.Join("/", parsedUrl.AbsolutePath.TrimStart('/').Split('/').Take(2));

			string? pathToFolderInDownloadedZip = null;
			if (parsedUrl.AbsolutePath.Contains("/tree/"))
			{
				var partAfterTree = parsedUrl.AbsolutePath.Split("/tree/")[1];
				if (partAfterTree.Contains('/'))
				{
					var partAfterTreeTree = partAfterTree.Split('/')[1];
					if (!string.IsNullOrWhiteSpace(partAfterTreeTree))
					{
						pathToFolderInDownloadedZip = $"{ownerSlashRepo.Split('/')[1]}-{tree}/{partAfterTreeTree}";
					}
				}
			}

			return ($"https://github.com/{ownerSlashRepo}/archive/refs/heads/{tree}.zip", pathToFolderInDownloadedZip);
		}
	}

	private bool skipInitialTick = true;

	public AutoUpdateService(Config config, ILogger<AutoUpdateService> logger)
	{
		this.config = config;
		this.logger = logger;
		timer = new PeriodicTimer(TimeSpan.FromMinutes(config.HostFilesAutoUpdaterCheckIntervalMinutes));
		httpClient = new HttpClient();
		logger.LogTrace("AutoUpdateService created");
	}

	protected override async Task ExecuteAsync(CancellationToken stoppingToken)
	{
		logger.LogTrace("AutoUpdateService main loop started");
		while (!stoppingToken.IsCancellationRequested)
		{
			// we may have downloaded the update before this loop was started
			// so in that case we dont need to enter instantly 
			if (!skipInitialTick)
			{
				// the first tick will be after the interval not immediately
				await timer.WaitForNextTickAsync(stoppingToken);
			}
			skipInitialTick = false;


			string? lastModified = await GetLatestEtag();
			if (lastModified is null)
			{ continue; }

			if (File.Exists(lastEtagFilePath))
			{
				var lastEtag = await File.ReadAllTextAsync(lastEtagFilePath);
				if (lastEtag == lastModified)
				{
					logger.LogTrace("No new update available");
					continue;
				}
			}

			await DownloadLatestAndExtract();
		}
	}

	public async Task<string?> GetLatestEtag()
	{
		var (url, _) = downloadUrl;

		var msg = new HttpRequestMessage(HttpMethod.Head, url);
		HttpResponseMessage? response = null;
		try
		{
			response = await httpClient.SendAsync(msg);
		}
		catch (System.Exception ex)
		{ 
			logger.LogError(ex, "Failed to send request");
			return null;
		}

		if (!response.IsSuccessStatusCode)
		{
			logger.LogError("Failed to get the latest release info, status code: {StatusCode}", response.StatusCode);
			return null;
		}

		var etag = response.Headers.FirstOrDefault(x => x.Key == HeaderNames.ETag).Value?.FirstOrDefault();
		if (etag is null)
		{
			etag = response.Content.Headers.FirstOrDefault(x => x.Key == HeaderNames.ETag).Value?.FirstOrDefault();
		}
		if (etag is null)
		{
			throw new Exception("ETag not found in the response headers");
		}
		
		logger.LogTrace("Latest ETag: {etag}", etag);

		return etag;
	}

	public async Task DownloadLatestAndExtract()
	{
		logger.LogInformation("Downloading the latest release...");
		var (downloadUrl, pathToFolderInDownloadedZip) = this.downloadUrl;
		var response = await httpClient.GetAsync(downloadUrl);
		if (!response.IsSuccessStatusCode)
		{
			logger.LogError("Failed to download the latest release, status code: {StatusCode}", response.StatusCode);
			return;
		}

		logger.LogTrace("OK response received, extracting the update...");

		Directory.CreateDirectory(Config.WWWRootPath);

		await using var stream = await response.Content.ReadAsStreamAsync();

		// find index.html inside the zip file, and extract the folder containing it
		using var archive = new ZipArchive(stream);
		var allEntries = archive.Entries;

		ZipArchiveEntry? indexHtmlEntry = null;
		foreach (var entry in allEntries)
		{
			if (!entry.FullName.EndsWith("index.html", StringComparison.InvariantCultureIgnoreCase))
			{ continue; }

			if (pathToFolderInDownloadedZip is not null && !entry.FullName.Replace('\\', '/').TrimStart('/').StartsWith(pathToFolderInDownloadedZip, StringComparison.InvariantCultureIgnoreCase))
			{ continue; }

			indexHtmlEntry = entry;
			break;
		}

		if (indexHtmlEntry is null)
		{
			logger.LogError("index.html not found in the update zip file");
			throw new Exception("index.html not found in the update zip file");
		}

		var indexHtmlEntryDirectory = Path.GetDirectoryName(indexHtmlEntry.FullName)!.Replace('\\', '/');

		var filesToExtract = allEntries.Where(entry => entry.FullName.Replace('\\', '/').StartsWith(indexHtmlEntryDirectory, StringComparison.InvariantCultureIgnoreCase) && !entry.FullName.EndsWith('/'));
		foreach (var entry in filesToExtract)
		{
			var outputPath = Path.Combine(Config.WWWRootPath, entry.FullName.Substring(indexHtmlEntryDirectory.Length).TrimStart('/'));
			var outputDirectory = Path.GetDirectoryName(outputPath)!;
			if (!Directory.Exists(outputDirectory))
			{
				Directory.CreateDirectory(outputDirectory); // recursive
			}

			entry.ExtractToFile(outputPath, true);
		}

		logger.LogInformation("Update extracted successfully");

		// delete files that are not in the new update
		var wwwRootFiles = Directory.GetFiles(Config.WWWRootPath, "*", SearchOption.AllDirectories).Select(file => file.Replace('\\', '/'));
		var filesToDelete = wwwRootFiles.Where(file => !filesToExtract.Any(entry => file.EndsWith(entry.FullName.Substring(indexHtmlEntryDirectory.Length).TrimStart('/'), StringComparison.InvariantCultureIgnoreCase)));

		logger.LogTrace("Deleting {count} old files...", filesToDelete.Count());

		foreach (var file in filesToDelete)
		{
			File.Delete(file);
			logger.LogTrace("Deleted old file: {file}", file);
		}

		if (filesToDelete.Any())
		{
			logger.LogInformation("Old files deleted");
		}

		// Save the etag
		var etag = response.Headers.FirstOrDefault(x => x.Key == HeaderNames.ETag).Value?.FirstOrDefault();
		if (etag is null)
		{
			etag = response.Content.Headers.FirstOrDefault(x => x.Key == HeaderNames.ETag).Value?.FirstOrDefault();
		}
		if (etag is null)
		{
			// This would make it so it downloads the update every tick so abort
			// but this shouldnt be reached
			throw new Exception("ETag not found in the response headers");
		}

		await File.WriteAllTextAsync(lastEtagFilePath, etag);

		await File.WriteAllTextAsync(lastDownloadedVersionFilePath, downloadUrl);

		skipInitialTick = false;
	}

	public async Task StartupFetchIfNeeded()
	{
		// if there isnt an index.html file already, download the latest release
		if (!File.Exists(Path.Combine(Config.WWWRootPath, "index.html")))
		{
			await DownloadLatestAndExtract();
			return;
		}

		// if the user changed the cached/no-cache setting, download the latest release
		if (!File.Exists(lastDownloadedVersionFilePath) || await File.ReadAllTextAsync(lastDownloadedVersionFilePath) != downloadUrl.url)
		{
			await DownloadLatestAndExtract();
			return;
		}

	}

}
